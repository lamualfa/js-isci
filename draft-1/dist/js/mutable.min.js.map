{"version":3,"sources":["mutable.min.js"],"names":["f","exports","_typeof","module","define","amd","window","global","self","this","isci","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","opts","KEYWORD_REGEX","RegExp","PARAM_REGEX","KEYWORD_HANDLERS","_objectSpread","keywordHandlers","next","g","matchedParam","matchedKeyword","keywordOpt","params","arguments","undefined","result","pattern","exec","substring","index","keywords","type","2","dateFormatAsString","asString","currentDate","format","Date","currentUnixTimestamp","now","date-format","3","reverse","str","reversed","incrNumber","startNumber","increaser","incrCharset","charsetLength","charset","currentIndex","indexCharset","incrCharsets","charsets","subCharset","subCharsetLength","4","floor","random","randomString","Math","maxLength","minLength","5","./libs/keywords/incr","./libs/keywords/rand","6","padWithZeros","vNumber","width","numAsString","addZero","date","ISO8601_FORMAT","timezoneOffset","m","randCharset","getDate","vMonth","getMonth","vYearLong","getFullYear","vYearShort","vYear","indexOf","vHour","getHours","vMinute","getMinutes","vSecond","getSeconds","vMillisecond","vTimeZone","getTimezoneOffset","abs","os","String","h","replace","setDatePart","part","local","value","regexp","missingValuesDate","matchers","offset","fn","formatted","extractDateParts","setUTCMinutes","reduce","match","filter","dateFns","sort","b","matches","parsedPattern","forEach","DATETIME_FORMAT","ABSOLUTETIME_FORMAT"],"mappings":"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","file":"mutable.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.isci = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\nmodule.exports = function(opts) {\n  const KEYWORD_REGEX = new RegExp('\\\\[([^\\\\[\\\\]]+)\\\\]');\n  const PARAM_REGEX = new RegExp('<([^<>]+)>');\n  const KEYWORD_HANDLERS = {\n    ...opts.keywordHandlers\n  };\n\n  const processKeyword = keywordOpt => {\n    return KEYWORD_HANDLERS[keywordOpt.type]\n      ? KEYWORD_HANDLERS[keywordOpt.type](keywordOpt)\n      : '';\n  };\n\n  /**\n   * Get next ID from ISCI Schema\n   * @returns {string}\n   * @param {object} isci ISCI Schema\n   * @param {string} isci.name ISCI Name\n   * @param {string} isci.pattern ISCI Pattern\n   * @param {object} isci.keywords ISCI Keywords\n   * @param {object} params Your parameter to be passed\n   */\n  const next = (isci, params = {}) => {\n    let result = isci.pattern;\n    let matchedParam;\n    let matchedKeyword;\n\n    while ((matchedParam = PARAM_REGEX.exec(result)) !== null)\n      result =\n        result.substring(0, matchedParam.index) +\n        (Object.prototype.hasOwnProperty.call(params, matchedParam[1])\n          ? params[matchedParam[1]]\n          : '') +\n        result.substring(matchedParam.index + matchedParam[0].length);\n\n    while ((matchedKeyword = KEYWORD_REGEX.exec(result)) !== null)\n      result =\n        result.substring(0, matchedKeyword.index) +\n        (isci.keywords[matchedKeyword[1]]\n          ? processKeyword(isci.keywords[matchedKeyword[1]])\n          : '') +\n        result.substring(matchedKeyword.index + matchedKeyword[0].length);\n\n    return result;\n  };\n\n  return { next };\n};\n\n},{}],2:[function(require,module,exports){\nconst { asString: dateFormatAsString } = require('date-format');\n\nmodule.exports = {\n  currentDate: keywordOpt => dateFormatAsString(keywordOpt.format, new Date()),\n  currentUnixTimestamp: () => Date.now()\n};\n\n},{\"date-format\":6}],3:[function(require,module,exports){\nconst reverse = str => {\n  let length = str.length;\n  let reversed = '';\n  while (length--) reversed += str[length];\n\n  return reversed;\n};\n\nmodule.exports = {\n  incrNumber: opts => {\n    const result = opts.startNumber + opts.index + opts.increaser;\n\n    opts.index += opts.increaser;\n\n    return result;\n  },\n  incrCharset: opts => {\n    const charsetLength = opts.charset.length;\n\n    let currentIndex = opts.index;\n    let length = opts.length;\n    let result = '';\n\n    while (length--) {\n      const indexCharset = currentIndex % charsetLength;\n\n      result += opts.charset[indexCharset];\n\n      currentIndex = (currentIndex - indexCharset) / charsetLength;\n    }\n\n    result = reverse(result);\n    opts.index += opts.increaser;\n\n    return result;\n  },\n  incrCharsets: opts => {\n    let result = '';\n    let index = opts.index;\n\n    let i = opts.charsets.length;\n    while (i--) {\n      const subCharset = opts.charsets[i];\n      const subCharsetLength = subCharset.length;\n\n      const indexCharset = index % subCharsetLength;\n\n      result += subCharset[indexCharset];\n\n      index = (index - indexCharset) / subCharsetLength;\n    }\n\n    result = reverse(result);\n    opts.index += opts.increaser;\n\n    return result;\n  }\n};\n\n},{}],4:[function(require,module,exports){\nconst randomString = (charset, length) => {\n  let result = '';\n\n  while (length--)\n    result += charset.charAt(Math.floor(Math.random() * charset.length));\n\n  return result;\n};\n\nmodule.exports = {\n  randCharset: keywordOpt =>\n    randomString(\n      keywordOpt.charset,\n      keywordOpt.length\n        ? keywordOpt.length\n        : Math.floor(\n            Math.random() * (keywordOpt.maxLength - keywordOpt.minLength + 1)\n          ) + keywordOpt.minLength\n    )\n};\n\n},{}],5:[function(require,module,exports){\nmodule.exports = require('./libs/createMutable')({\n  keywordHandlers: {\n    ...require('./libs/keywords/date'),\n    ...require('./libs/keywords/incr'),\n    ...require('./libs/keywords/rand')\n  }\n});\n\n},{\"./libs/createMutable\":1,\"./libs/keywords/date\":2,\"./libs/keywords/incr\":3,\"./libs/keywords/rand\":4}],6:[function(require,module,exports){\n\"use strict\";\n\nfunction padWithZeros(vNumber, width) {\n  var numAsString = vNumber.toString();\n  while (numAsString.length < width) {\n    numAsString = \"0\" + numAsString;\n  }\n  return numAsString;\n}\n\nfunction addZero(vNumber) {\n  return padWithZeros(vNumber, 2);\n}\n\n/**\n * Formats the TimeOffset\n * Thanks to http://www.svendtofte.com/code/date_format/\n * @private\n */\nfunction offset(timezoneOffset) {\n  var os = Math.abs(timezoneOffset);\n  var h = String(Math.floor(os / 60));\n  var m = String(os % 60);\n  if (h.length === 1) {\n    h = \"0\" + h;\n  }\n  if (m.length === 1) {\n    m = \"0\" + m;\n  }\n  return timezoneOffset < 0 ? \"+\" + h + m : \"-\" + h + m;\n}\n\nfunction asString(format, date) {\n  if (typeof format !== \"string\") {\n    date = format;\n    format = module.exports.ISO8601_FORMAT;\n  }\n  if (!date) {\n    date = module.exports.now();\n  }\n\n  // Issue # 14 - Per ISO8601 standard, the time string should be local time\n  // with timezone info.\n  // See https://en.wikipedia.org/wiki/ISO_8601 section \"Time offsets from UTC\"\n\n  var vDay = addZero(date.getDate());\n  var vMonth = addZero(date.getMonth() + 1);\n  var vYearLong = addZero(date.getFullYear());\n  var vYearShort = addZero(vYearLong.substring(2, 4));\n  var vYear = format.indexOf(\"yyyy\") > -1 ? vYearLong : vYearShort;\n  var vHour = addZero(date.getHours());\n  var vMinute = addZero(date.getMinutes());\n  var vSecond = addZero(date.getSeconds());\n  var vMillisecond = padWithZeros(date.getMilliseconds(), 3);\n  var vTimeZone = offset(date.getTimezoneOffset());\n  var formatted = format\n    .replace(/dd/g, vDay)\n    .replace(/MM/g, vMonth)\n    .replace(/y{1,4}/g, vYear)\n    .replace(/hh/g, vHour)\n    .replace(/mm/g, vMinute)\n    .replace(/ss/g, vSecond)\n    .replace(/SSS/g, vMillisecond)\n    .replace(/O/g, vTimeZone);\n  return formatted;\n}\n\nfunction setDatePart(date, part, value, local) {\n  date['set' + (local ? '' : 'UTC') + part](value);\n}\n\nfunction extractDateParts(pattern, str, missingValuesDate) {\n  // Javascript Date object doesn't support custom timezone.  Sets all felds as\n  // GMT based to begin with.  If the timezone offset is provided, then adjust\n  // it using provided timezone, otherwise, adjust it with the system timezone.\n  var local = pattern.indexOf('O') < 0;\n  var matchers = [\n    {\n      pattern: /y{1,4}/,\n      regexp: \"\\\\d{1,4}\",\n      fn: function(date, value) {\n        setDatePart(date, 'FullYear', value, local);\n      }\n    },\n    {\n      pattern: /MM/,\n      regexp: \"\\\\d{1,2}\",\n      fn: function(date, value) {\n        setDatePart(date, 'Month', (value - 1), local);\n      }\n    },\n    {\n      pattern: /dd/,\n      regexp: \"\\\\d{1,2}\",\n      fn: function(date, value) {\n        setDatePart(date, 'Date', value, local);\n      }\n    },\n    {\n      pattern: /hh/,\n      regexp: \"\\\\d{1,2}\",\n      fn: function(date, value) {\n        setDatePart(date, 'Hours', value, local);\n      }\n    },\n    {\n      pattern: /mm/,\n      regexp: \"\\\\d\\\\d\",\n      fn: function(date, value) {\n        setDatePart(date, 'Minutes', value, local);\n      }\n    },\n    {\n      pattern: /ss/,\n      regexp: \"\\\\d\\\\d\",\n      fn: function(date, value) {\n        setDatePart(date, 'Seconds', value, local);\n      }\n    },\n    {\n      pattern: /SSS/,\n      regexp: \"\\\\d\\\\d\\\\d\",\n      fn: function(date, value) {\n        setDatePart(date, 'Milliseconds', value, local);\n      }\n    },\n    {\n      pattern: /O/,\n      regexp: \"[+-]\\\\d{3,4}|Z\",\n      fn: function(date, value) {\n        if (value === \"Z\") {\n          value = 0;\n        }\n        var offset = Math.abs(value);\n        var timezoneOffset = (value > 0 ? -1 :  1 ) * ((offset % 100) + Math.floor(offset / 100) * 60);\n        // Per ISO8601 standard: UTC = local time - offset\n        //\n        // For example, 2000-01-01T01:00:00-0700\n        //   local time: 2000-01-01T01:00:00\n        //   ==> UTC   : 2000-01-01T08:00:00 ( 01 - (-7) = 8 )\n        //\n        // To make it even more confusing, the date.getTimezoneOffset() is\n        // opposite sign of offset string in the ISO8601 standard.  So if offset\n        // is '-0700' the getTimezoneOffset() would be (+)420. The line above\n        // calculates timezoneOffset to matche Javascript's behavior.\n        //\n        // The date/time of the input is actually the local time, so the date\n        // object that was constructed is actually local time even thought the\n        // UTC setters are used.  This means the date object's internal UTC\n        // representation was wrong.  It needs to be fixed by substracting the\n        // offset (or adding the offset minutes as they are opposite sign).\n        //\n        // Note: the time zone has to be processed after all other fileds are\n        // set.  The result would be incorrect if the offset was calculated\n        // first then overriden by the other filed setters.\n        date.setUTCMinutes(date.getUTCMinutes() + timezoneOffset);\n      }\n    }\n  ];\n\n  var parsedPattern = matchers.reduce(\n    function(p, m) {\n      if (m.pattern.test(p.regexp)) {\n        m.index = p.regexp.match(m.pattern).index;\n        p.regexp = p.regexp.replace(m.pattern, \"(\" + m.regexp + \")\");\n      } else {\n        m.index = -1;\n      }\n      return p;\n    },\n    { regexp: pattern, index: [] }\n  );\n\n  var dateFns = matchers.filter(function(m) {\n    return m.index > -1;\n  });\n  dateFns.sort(function(a, b) {\n    return a.index - b.index;\n  });\n\n  var matcher = new RegExp(parsedPattern.regexp);\n  var matches = matcher.exec(str);\n  if (matches) {\n    var date = missingValuesDate || module.exports.now();\n    dateFns.forEach(function(f, i) {\n      f.fn(date, matches[i + 1]);\n    });\n\n    return date;\n  }\n\n  throw new Error(\n    \"String '\" + str + \"' could not be parsed as '\" + pattern + \"'\"\n  );\n}\n\nfunction parse(pattern, str, missingValuesDate) {\n  if (!pattern) {\n    throw new Error(\"pattern must be supplied\");\n  }\n\n  return extractDateParts(pattern, str, missingValuesDate);\n}\n\n/**\n * Used for testing - replace this function with a fixed date.\n */\nfunction now() {\n  return new Date();\n}\n\nmodule.exports = asString;\nmodule.exports.asString = asString;\nmodule.exports.parse = parse;\nmodule.exports.now = now;\nmodule.exports.ISO8601_FORMAT = \"yyyy-MM-ddThh:mm:ss.SSS\";\nmodule.exports.ISO8601_WITH_TZ_OFFSET_FORMAT = \"yyyy-MM-ddThh:mm:ss.SSSO\";\nmodule.exports.DATETIME_FORMAT = \"dd MM yyyy hh:mm:ss.SSS\";\nmodule.exports.ABSOLUTETIME_FORMAT = \"hh:mm:ss.SSS\";\n\n},{}]},{},[5])(5)\n});\n"]}